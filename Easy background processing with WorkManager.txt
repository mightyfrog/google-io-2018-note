Android Jetpack: easy background processing with WorkManager
https://www.youtube.com/watch?v=IrKoBFLwTN0

There are many way to do background jobs in Android (0:55)
  - Threads
  - Executors
  - Services
  - AsyncTasks
  - Handlers and Loopers
  - Jobs (API 21+)
  - GcmNetworkManager
  - SyncAdapters
  - Loaders
  - AlarmManager


Android battery optimizations (1:06)
  - Doze mode (M)
  - Ap standby (M)
  - Limited implicit broadcasts (N)
  - Release cached wakelocks (O)
  - Background service limitations (O)
  - App standby buckets (P)
  - Background restricted apps (P)


Backword compatibility diagram (1:30)


Types of background work (1:40)
  There are four things to be considered
    - Exact timing
    - Deferrable
    - Best-effort
    - Guaranteed execution

What are your requirements? (Diagram) (3:20)


WorkManager features (4:05)
  - Guaranteed, constraint-aware execution
  - Respectful of system background restrictions
  - Backwards compatible with or without Google Play Services
  - Queryable
  - Chainable
  - Opportunistic


Core classes
  - Worker
  - WorkRequest
    - OneTimeWorkRequest
    - PeriodicWorkRequest


	class UPloadPhotoWorker : Worker() {
		override fun doWork(): WorkerResult {
			uploadPhot()
			return WorkResult.SUCCESS (or FAILURE, RETRY)
		}
	}

	val request: WorkRequest = OneTimeWorkRequestBuilder<UploadPhotoWorker>().build()
	WorkManager.getInstance().enqueue(request)

	What if there's no connection? Use constraints.

	val constraints = Constraints.Builder().setRequiredNetworkType(NetworkType.CONNECTED).build()
	val request = OneTimeWorkRequestBuilder<UploadPhotoWorker>().setConstraints(constraints).build()
	...


Observinb work (7:07)	
	Wants to show a progress indicator. How?

	workManager.enqueu(request)
	val status: LiveData<WorkStatus = workManager.getStatusById(request.id)
	status.observe(lifecycleOwner, Observer {
		if (it != null && it.state.isFinished) {
			progressBar.setVisibility(View.GONE)
		}
	})


Chaining work (8:13)

	val work1 = ...
	val work2 = ...
	workManager.beginWith(work1).then(work2).enqueue() // WorkContinuation behind the scene


How to do parallel background works?

	val work1 = ...
	val work2 = ...
	val work3 = ...
	workManager.enqueue(work1, work2, work3)

Parallel works can be combined together and then passed to to .then(nextWork)


Input & Output (10:30)

Data (11:35)
   - Simple key-value map
     - keys are strings
     - values are primitives and strings, with array versions as well
   - serializable by Workmanager
   - Limited to 10KB when serialized

   class CountWordsWorker : Worker() {
        override fun doWork(): WorkResult {
        	val inputData: Data = getInputData()
        	val fileName = inputData.getString("file_name", "default_val")
        	val wordMap: Map = countWordOccurrences(fileName)
        	val outputData: Data = wordMap.toWorkData()
        	setOutputData(outputData)
        	return WorkResult.SUCCESS
        }
   }

A worker's outputs become inputs for its children.


InputMerger (14:05)
  - Combines Data from multiple sources into one Data
  - Two implementations out of the box
    - OverwritingInputMerger (default)
    - ArrayCreatingInputMerger
  - Or specify your own

OverwritingInputMerger Diagram (15:00)

ArrayCreatingInputMerger Diagram (15:50)
  - throws an exception if merging values are of different types


Cancelling work (17:19)

	workManager.cancelWorkById(request.id) // Cancellation is best-effort!!


Tags (17:53)
 IDs are autogenerated and aren't human readable

 Tags provide a more readable way to identify your work
 	- tags are developer-sepcified strings
 	- each WorkReqeust can have zero or more tags
 	- you can query and cancel work by tags

 	workRequest.addTag("user1").addTag("get_favorites")

 	val statusLiveData: LiveData<List<WorkStatus>> = workManager.getStatusesByTag("user1")

 	workManager.cancelAllWorksByTag("get_favorites")


Unique work (20:30)
	- A chain of work can be given a unique name
	- You can enqueue, query, and cancel work by name
	- There can be only one chain of work with a given name

	val syncRequest: OneTimeWorkRequest = workManager.beginUniqueWork("sync", KEEP, syncRequest).enquque() // the second argument (ExistingWorkPolicy) decides what to do with an existing in-flight unique work with this name.

Three ExistingWorkPolicy types: KEEP, REPLACE, APPEND


PeriodicWork basics (24:20)
	- minimum period length is 15 minutes (same as JobScheduler)
	- subject to doze mode / OS background restrictions
	- cannot be chained
	- cannot have initial delays


Under the hood diagram (25:45)


Implementation details (26:00)
	- JobScheduler and Firebase JobDispatcher provide a central load-balancing mechanism across apps; AlarmManager does not
	- Newer concepts (idle, content URI triggers) are only available at API levels where they were introudced
	- We take care of obtaining wake locks when necessary


Use the testing library (27:00)
	- Synchronous executor
	- Use WorkManager to enqueue your requests
	- Use TestDriver to execute enqueued work
	- Periodic and initial delay triggers coming soon

	fun test() {
		WorkManagerTestInitHelper.initializeTestWorkManager(context)
		val testDriver: TestDriver = WorkManagerTestInitHelper.getTestDriver()
		val constraintedWork: OneTimeWorkRequest = workManager.enqueue(contrainedWork)
		testDriver.setAllConstraintsMet(constrainedWork.id)
		verify(...)
	}


Best practices (27:40)
	When to use WorkManager: For tasks that can survice process death
		- OK: upload to server
		- OK: parse data and store it in database
		- NOT OK: extract palette color and update ImageView
		- NOT OK: parse data and update TextView
		- NOT OK: process payment transaction (Use ForegroundService)

	This is not your data store
		- instances of Data are limited to 10KB each (serialized)
		- they are meant for:
			- light intermediate data
			- file URIs
			- simple information to update your UI

	Use Room for full data store


Be opportunistic diagram (29:23)


WorkManager is in alpha (30:22)

http://developer.android.com/arch/work